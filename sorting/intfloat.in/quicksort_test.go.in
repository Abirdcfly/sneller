// Copyright (C) 2022 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package sorting

// Code generated by generator.go; DO NOT EDIT.

import (
	"math/rand"
	"sort"
	"testing"
	"runtime"
)

type InputType int

const (
	Random InputType = iota
	Random1to10
	Random1to100
	AscendingMaxInt
	Ascending1to10
	Ascending1to100
	DescendingMaxInt
	Descending1to10
	Descending1to100
)

// make it less than (2^31 - 1) to be safe for all types, signed and unsigned
const maxrand int = 10000000

// --- unit tests -----------------------------------
{{ with $p := . }}
{{ range $index, $dt := $p.DataTypes }}
{{ range $index, $inputType := $p.InputTypes }}
func TestQuicksortAVX512Asc{{$dt.Suffix}}{{$inputType}}(t* testing.T) {
	quicksortAVX512AscSingleThreadTest{{$dt.Suffix}}(t, 100, {{$inputType}})
}

func TestQuicksortAVX512Desc{{$dt.Suffix}}{{$inputType}}(t* testing.T) {
	quicksortAVX512DescSingleThreadTest{{$dt.Suffix}}(t, 100, {{$inputType}})
}
{{ end }}
{{ end }}
{{ end }}


// --- benchmarks -----------------------------------
{{ with $p := . }}
{{ range $index, $dt := $p.DataTypes }}
{{ range $index, $inputType := $p.InputTypes }}
{{ range $index, $size := $p.InputSizes }}
func BenchmarkGolangQuicksort{{$dt.Suffix}}{{$inputType}}Size{{$size}} (b* testing.B) {
	golangQuicksortBenchmark{{$dt.Suffix}}(b, {{$size}}, {{$inputType}})
}

func BenchmarkGolangQuicksortSingleThread{{$dt.Suffix}}{{$inputType}}Size{{$size}} (b* testing.B) {
	golangQuicksortSingleThreadBenchmark{{$dt.Suffix}}(b, {{$size}}, {{$inputType}})
}

func BenchmarkAVX512Quicksort{{$dt.Suffix}}{{$inputType}}Size{{$size}} (b* testing.B) {
	quicksortAVX512Benchmark{{$dt.Suffix}}(b, {{$size}}, {{$inputType}})
}

func BenchmarkAVX512QuicksortSingleThread{{$dt.Suffix}}{{$inputType}}Size{{$size}} (b* testing.B) {
	quicksortAVX512SingleThreadBenchmark{{$dt.Suffix}}(b, {{$size}}, {{$inputType}})
}

func BenchmarkGolangStdSortSingleThread{{$dt.Suffix}}{{$inputType}}Size{{$size}} (b* testing.B) {
	golangStdSortSingleThreadBenchmark{{$dt.Suffix}}(b, {{$size}}, {{$inputType}})
}
{{ end }}
{{ end }}
{{ end }}
{{ end }}

// --------------------------------------------------

type dummySortedDataWriter struct{}

func (w *dummySortedDataWriter) Write(int, int) error { return nil }

// --------------------------------------------------

{{ range .DataTypes }}
func golangQuicksortBenchmark{{.Suffix}}(b *testing.B, size int, inputType InputType) {
	keys, indices := prepareInput{{.Suffix}}(size, inputType)

	threads := runtime.NumCPU()
	rp := NewRuntimeParameters(threads)
	pool := NewThreadPool(threads)
	writer := new(dummySortedDataWriter)
	consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
	consumer.Start(pool)

	b.SetBytes(int64(size) * {{.KeySize}})
	b.ResetTimer()

	quicksort{{.Suffix}}(keys, indices, pool, Ascending, consumer, &rp)
	pool.Wait()
}

func golangQuicksortSingleThreadBenchmark{{.Suffix}}(b *testing.B, size int, inputType InputType) {
	keys, indices := prepareInput{{.Suffix}}(size, inputType)

	threads := 1
	rp := NewRuntimeParameters(threads)
	pool := NewThreadPool(threads)
	writer := new(dummySortedDataWriter)
	consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
	consumer.Start(pool)

	b.SetBytes(int64(size) * {{.KeySize}})
	b.ResetTimer()

	quicksortAVX512{{.Suffix}}(keys, indices, pool, Ascending, consumer, &rp)
	pool.Wait()
}

func golangStdSortSingleThreadBenchmark{{.Suffix}}(b *testing.B, size int, inputType InputType) {
	keys, indices := prepareInput{{.Suffix}}(size, inputType)

	b.SetBytes(int64(size) * {{.KeySize}})
	b.ResetTimer()

	sort.Sort(&sort{{.Suffix}}Asc{keys, indices})
}

func quicksortAVX512Benchmark{{.Suffix}}(b *testing.B, size int, inputType InputType) {
	keys, indices := prepareInput{{.Suffix}}(size, inputType)

	threads := runtime.NumCPU()
	rp := NewRuntimeParameters(threads)
	pool := NewThreadPool(threads)
	writer := new(dummySortedDataWriter)
	consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
	consumer.Start(pool)

	b.SetBytes(int64(size) * {{.KeySize}})
	b.ResetTimer()

	quicksortAVX512{{.Suffix}}(keys, indices, pool, Ascending, consumer, &rp)
	pool.Wait()
}

func quicksortAVX512SingleThreadBenchmark{{.Suffix}}(b *testing.B, size int, inputType InputType) {
	keys, indices := prepareInput{{.Suffix}}(size, inputType)

	threads := 1
	rp := NewRuntimeParameters(threads)
	pool := NewThreadPool(threads)
	writer := new(dummySortedDataWriter)
	consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
	consumer.Start(pool)

	b.SetBytes(int64(size) * {{.KeySize}})
	b.ResetTimer()

	quicksortAVX512{{.Suffix}}(keys, indices, pool, Ascending, consumer, &rp)
	pool.Wait()
}

// --------------------------------------------------

func quicksortAVX512AscSingleThreadTest{{.Suffix}}(t *testing.T, maxsize int, inputType InputType) {
	for size := 1; size <= maxsize; size++ {
		keys, indices := prepareInput{{.Suffix}}(size, inputType)

		threads := runtime.NumCPU()
		rp := NewRuntimeParameters(threads)
		pool := NewThreadPool(threads)
		writer := new(dummySortedDataWriter)
		consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
		consumer.Start(pool)

		quicksortAVX512{{.Suffix}}(keys, indices, pool, Ascending, consumer, &rp)
		pool.Wait()

		if !isSortedAsc{{.Suffix}}(indices) {
			t.Fatalf("Indices are not sorted (size %d)", size)
		}
	}
}

// --------------------------------------------------

func quicksortAVX512DescSingleThreadTest{{.Suffix}}(t *testing.T, maxsize int, inputType InputType) {
	for size := 1; size <= maxsize; size++ {
		keys, indices := prepareInput{{.Suffix}}(size, inputType)

		threads := 1
		rp := NewRuntimeParameters(threads)
		pool := NewThreadPool(threads)
		writer := new(dummySortedDataWriter)
		consumer := NewAsyncConsumer(writer, 0, len(indices) - 1, nil)
		consumer.Start(pool)

		quicksortAVX512{{.Suffix}}(keys, indices, pool, Descending, consumer, &rp)
		pool.Wait()

		if !isSortedDesc{{.Suffix}}(indices) {
			t.Fatalf("Indices are not sorted (size %d)", size)
		}
	}
}

// --------------------------------------------------

func prepareInput{{.Suffix}}(size int, inputType InputType) (keys []{{.KeyType}}, indices []{{.IndexType}}) {
	keys = make([]{{.KeyType}}, size)
	indices = make([]{{.IndexType}}, size)

	random := func(shift {{.KeyType}}, maxint int) {
		for j := 0; j < len(keys); j++ {
			r := rand.Intn(maxint)
			keys[j] = shift + {{.KeyType}}(r)
			indices[j] = {{.IndexType}}(r * 10)
		}
	}

	ascending := func(shift {{.KeyType}}, maxint int) {
		for j := 0; j < len(keys); j++ {
			keys[j] = {{.KeyType}}(rand.Intn(maxrand))
		}

		sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })
		for j := 0; j < len(keys); j++ {
			indices[j] = {{.IndexType}}(keys[j])
		}
	}

	descending := func(shift {{.KeyType}}, maxint int) {
		for j := 0; j < len(keys); j++ {
			keys[j] = {{.KeyType}}(rand.Intn(maxrand))
		}

		sort.Slice(keys, func(i, j int) bool { return keys[i] > keys[j] })
		for j := 0; j < len(keys); j++ {
			indices[j] = {{.IndexType}}(keys[j])
		}
	}

	switch inputType {
	case Random:
		random(0, maxrand)
	case Random1to10:
		random(1, 10)
	case Random1to100:
		random(1, 100)
	case AscendingMaxInt:
		ascending(0, maxrand)
	case Ascending1to10:
		ascending(1, 10)
	case Ascending1to100:
		ascending(1, 100)
	case DescendingMaxInt:
		descending(0, maxrand)
	case Descending1to10:
		descending(1, 10)
	case Descending1to100:
		descending(1, 100)
	default:
		panic("Wrong enum value")
	}

	return keys, indices
}
{{ end }}
