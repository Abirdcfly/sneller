// Code generated by Ragel. DO NOT EDIT.

package date

import (
       "time"
)

// TODO: support more date formats
// than simply rfc3339
%%{
    machine date;

    # see rfc3339; this is more-or-less verbatim

    # year: any 4 digits
    fullyear = (digit{4}) %{{
        year = int(data[p-4]-'0')*1000
        year += int(data[p-3]-'0')*100
        year += int(data[p-2]-'0')*10
        year += int(data[p-1]-'0')
    }};
    # day: 01-31
    day = (('0' . [1-9]) | ([12] . digit) | ('3' . [01])) %{{
        day = int(data[p-2]-'0')*10
        day += int(data[p-1]-'0')
    }};
    # month: 01-12
    month = (('0' [1-9]) | ('1' [012])) %{{
        month = int(data[p-2]-'0')*10
        month += int(data[p-1]-'0')
    }};
    # hour: 00-23
    hour = (('0' digit) | ('1' digit) | ('2' [0-3])) %{{
        hour = int(data[p-2]-'0')*10
        hour += int(data[p-1]-'0')
    }};
    # minute: 00-59
    minute = [0-5] digit %{{
        minute = int(data[p-2]-'0')*10
        minute += int(data[p-1]-'0')
    }};
    second = (([0-5] digit) @{{
        second = int(data[p-1]-'0')*10
        second += int(data[p]-'0')
    }}) | "60" %{ second = 60 };     # 00 to 60
    # fractional seconds
    secfrac = '.' (digit{1,9}) ${{
        frac *= 10
        frac += int(data[p]-'0')
        fracdig /= 10
    }};

    action save_hm {
        hoursave, minutesave = hour, minute;
        hour, minute = 0, 0;
    }
    action negoff { negoff = true }
    action setloc {{
        offset := 3600*hour + 60*minute
        if negoff {
           offset = -offset
        }
        loc = time.FixedZone("", offset)
        hour, minute = hoursave, minutesave
    }}

    offset = ('+' | ('-' %negoff)) >save_hm (hour ':' minute) @setloc;
    partial_time = hour ':' minute ':' second (secfrac)?;
    date = fullyear '-' month '-' day;
    time_offset = 'Z' | offset;

    # note: RFC3339 requires the offset,
    # but we can handle more inputs if we make it optional:
    full_time = partial_time time_offset?;

    # in order to support some ISO8601 timestamps,
    # allow ' ' instead of 'T' as a separator:
    main := space* date ('T' | ' ') full_time space*;
}%%

// Parse parses a date string from data
// and returns the associated time and true,
// or the zero time value and false if the buffer
// did not contain a recognzied date format.
//
// Parse attempts to recognize strings
// that (approximately) match RFC3339 timestamps
// with optional nanosecond precision and timezone/offset
// components. Parse will automatically ignore leading
// and trailing whitespace as long as the middle characters
// of data are unambiguously a timestamp.
//
//
func Parse(data []byte) (time.Time, bool) {
    cs, p, pe, eof := 0, 0, len(data), -1
    loc := time.UTC
    // fractional component; divided by ten
    // for each decimal place after '.' that we scan
    fracdig := int(time.Second)
    negoff := false
    hoursave, minutesave := 0, 0
    year, month, day, hour, minute, second, frac := 0, 0, 0, 0, 0, 0, 0

    %%{
        write data;
        write init;
        write exec;
    }%%
    if cs < date_first_final {
        return time.Time{}, false
    }
    nsec := 0
    if frac != 0 {
        nsec = frac * fracdig;
    }
    return time.Date(year, time.Month(month), day, hour, minute, second, nsec, loc), true
}
