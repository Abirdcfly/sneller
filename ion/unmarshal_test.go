// Copyright (C) 2022 Sneller, Inc.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package ion

import (
	"math"
	"testing"

	"github.com/SnellerInc/sneller/date"
)

func TestReadInt(t *testing.T) {
	ints := []int64{
		math.MinInt64,
		-1025, -1024, -1023,
		-1, 0, 1,
		65534, 65535, 65536,
		math.MaxInt64,
	}
	var buf Buffer
	for _, i := range ints {
		buf.Reset()
		buf.WriteInt(i)
		val, rest, err := ReadInt(buf.Bytes())
		if err != nil {
			t.Fatal(err)
		}
		if len(rest) > 0 {
			t.Errorf("case i=%d %d bytes left over", i, len(rest))
		}
		if val != i {
			t.Errorf("%d in -> %d out", i, val)
		}
	}
}

func TestReadIntMagnitudeFromValidIon(t *testing.T) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20}},
		{255, []byte{0x21, 0xff}},
		{65535, []byte{0x22, 0xff, 0xff}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{1, []byte{0x21, 0x01}},
		{257, []byte{0x22, 0x01, 0x01}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1, []byte{0x21, 0x01}},
		{258, []byte{0x22, 0x01, 0x02}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}},
		{127, []byte{0x21, 0x7f}},
		{32639, []byte{0x22, 0x7f, 0x7f}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
	}

	for _, input := range testcases {
		val, tail, err := ReadIntMagnitude(input.encoded)
		if err != nil {
			t.Errorf("input % 02x: unexpected error %v", input.encoded, err)
		}
		if len(tail) != 0 {
			t.Errorf("input % 02x: the whole input should be consumed but % 02x left", input.encoded, tail)
		}
		if val != input.value {
			t.Errorf("input % 02x: expected value %d, got %d", input.encoded, input.value, val)
		}
	}
}

func TestReadIntMagnitudeFromValidIonWithExtraPaddingAfterValues(t *testing.T) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{255, []byte{0x21, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65535, []byte{0x22, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{257, []byte{0x22, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{258, []byte{0x22, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{127, []byte{0x21, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{32639, []byte{0x22, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	}

	for _, input := range testcases {
		val, tail, err := ReadIntMagnitude(input.encoded)
		if err != nil {
			t.Errorf("input % 02x: unexpected error %v", input.encoded, err)
		}
		if len(tail) != 8 {
			t.Errorf("input % 02x: the input should be consumed and 8-byte tail be returned but % 02x left", input.encoded, tail)
		}
		if val != input.value {
			t.Errorf("input % 02x: expected value %d, got %d", input.encoded, input.value, val)
		}
	}
}

func TestReadIntMagnitudeDetectsInvalidIon(t *testing.T) {
	testcases := []struct {
		encoded []byte
		errmsg  string
	}{
		{[]byte{0x50}, "ion.ReadIntMagnitude: found type decimal, wanted an integer type"},
		{[]byte{0x21}, "invalid TLV encoding bytes"}, // truncated
		{[]byte{0x2e, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			"integer of 10 bytes out of range"},
	}

	for _, input := range testcases {
		_, _, err := ReadIntMagnitude(input.encoded)
		if err == nil {
			t.Errorf("input % 02x: expected error to be returned", input.encoded)
			continue
		}

		if err.Error() != input.errmsg {
			t.Errorf("input % 02x: expected error message %s, got %s",
				input.encoded, input.errmsg, err.Error())
		}
	}
}

func BenchmarkReadIntMagnitude(b *testing.B) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20}},
		{255, []byte{0x21, 0xff}},
		{65535, []byte{0x22, 0xff, 0xff}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}},
		{1, []byte{0x21, 0x01}},
		{257, []byte{0x22, 0x01, 0x01}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}},
		{127, []byte{0x21, 0x7f}},
		{32639, []byte{0x22, 0x7f, 0x7f}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f}},
	}

	for i := 0; i < b.N; i++ {
		for _, input := range testcases {
			_, _, _ = ReadIntMagnitude(input.encoded)
		}
	}
}

func BenchmarkReadIntMagnitudeFromIonWithExtraPaddingAfterValues(b *testing.B) {
	testcases := []struct {
		value   uint64
		encoded []byte
	}{
		{0, []byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{255, []byte{0x21, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65535, []byte{0x22, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16777215, []byte{0x23, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4294967295, []byte{0x24, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1099511627775, []byte{0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{281474976710655, []byte{0x26, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72057594037927935, []byte{0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{18446744073709551615, []byte{0x28, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{257, []byte{0x22, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{65793, []byte{0x23, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16843009, []byte{0x24, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4311810305, []byte{0x25, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1103823438081, []byte{0x26, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{282578800148737, []byte{0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72340172838076673, []byte{0x28, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1, []byte{0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{258, []byte{0x22, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{66051, []byte{0x23, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{16909060, []byte{0x24, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{4328719365, []byte{0x25, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{1108152157446, []byte{0x26, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{283686952306183, []byte{0x27, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{72623859790382856, []byte{0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{127, []byte{0x21, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{32639, []byte{0x22, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{8355711, []byte{0x23, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{2139062143, []byte{0x24, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{547599908735, []byte{0x25, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{140185576636287, []byte{0x26, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{35887507618889599, []byte{0x27, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
		{9187201950435737471, []byte{0x28, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
	}

	for i := 0; i < b.N; i++ {
		for _, input := range testcases {
			_, _, _ = ReadIntMagnitude(input.encoded)
		}
	}
}

func BenchmarkReadTime(b *testing.B) {
	mkts := func(s string) []byte {
		d, ok := date.Parse([]byte(s))
		if !ok {
			panic("bad date: " + s)
		}
		var b Buffer
		b.WriteTime(d)
		return b.Bytes()
	}
	times := [][]byte{
		mkts("2022-04-05T07:20:50"),
		mkts("2022-04-05T07:20:50.52334"),
		mkts("2022-04-05T12:24:32.999999999"),
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ReadTime(times[i%len(times)])
	}
}

func BenchmarkWriteTime(b *testing.B) {
	mkts := func(s string) date.Time {
		d, ok := date.Parse([]byte(s))
		if !ok {
			panic("bad date: " + s)
		}
		return d
	}
	times := []date.Time{
		mkts("2022-04-05T07:20:50"),
		mkts("2022-04-05T07:20:50.52334"),
		mkts("2022-04-05T12:24:32.999999999"),
	}
	var buf Buffer
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		buf.WriteTime(times[i%len(times)])
		buf.Reset()
	}
}
